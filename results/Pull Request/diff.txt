diff --git a/ChulanovAndrey/.gitignore b/ChulanovAndrey/.gitignore
new file mode 100644
index 0000000..a28eac2
--- /dev/null
+++ b/ChulanovAndrey/.gitignore
@@ -0,0 +1,5 @@
+/Driver
+/Driver.cmi
+/Driver.cmo
+/Expr.cmi
+/Expr.cmo
diff --git a/ChulanovAndrey/Driver.ml b/ChulanovAndrey/Driver.ml
new file mode 100644
index 0000000..7d4f058
--- /dev/null
+++ b/ChulanovAndrey/Driver.ml
@@ -0,0 +1,59 @@
+open Language
+open Expr
+open Stmt
+open Ostap
+open Ostap.Util
+open GT
+
+
+let rec expr_parse s =                                                                                    
+	expr id
+	[|                                                                                            
+		`Lefta , [ostap ("+"), (fun x y -> Add (x, y))]; 
+		`Lefta , [ostap ("*"), (fun x y -> Mul (x, y))]  
+	|]                                                                                            
+	primary                                                                                       
+	s                                                                                             
+	and ostap (primary:  
+		n:DECIMAL {Const n}  
+		| e:IDENT   {Var e}
+		| -"(" expr_parse -")") 
+		
+ostap (
+  simp: x:IDENT ":=" e:expr_parse     {Assign (x, e)}
+      | %"read" "(" x:IDENT ")" {Read x}
+      | %"write" "(" e:expr_parse ")" {Write e}
+      | %"skip"                 {Skip};
+      
+  stmt: s:simp ";" d:stmt {Seq (s,d)}
+      | simp 
+)
+
+let parse filename = 
+  let s = Util.read filename in
+  Util.parse 
+    (object 
+       inherit Matcher.t s 
+       inherit Util.Lexers.ident ["read"; "write"; "skip"] s
+       inherit Util.Lexers.decimal s
+       inherit Util.Lexers.skip [
+         Matcher.Skip.whitespaces " \t\n"
+       ] s
+    end)
+    (ostap (stmt -EOF))
+    
+let _ =
+  match Sys.argv with
+  | [|_; filename|] ->
+      match parse filename with
+      | `Ok stmt -> 
+        let basename = Filename.chop_suffix filename ".expr" in      
+        let text = X86.compile stmt in
+        Printf.printf "%s\n" (show (Stmt.t) stmt);
+        let asm  = basename ^ ".s" in
+        let ouch = open_out asm   in
+      Printf.fprintf ouch "%s\n" text;
+      close_out ouch;
+        let runtime = try Sys.getenv "RUNTIME" with _ -> "../runtime" in
+        ignore @@ Sys.command (Printf.sprintf "gcc -m32 -o %s %s/runtime.o %s.s" basename runtime basename)
+      | `Fail e -> Printf.eprintf "Parsing error: %s\n" e
diff --git a/ChulanovAndrey/Interpret.ml b/ChulanovAndrey/Interpret.ml
new file mode 100644
index 0000000..ff16b03
--- /dev/null
+++ b/ChulanovAndrey/Interpret.ml
@@ -0,0 +1,49 @@
+open Language
+
+(* Interpreter for expressions *)
+module Expr =
+  struct
+
+    open Expr
+
+    let rec eval expr st = 
+      let eval' e = eval e st in
+      match expr with
+      | Var   x     -> st x
+      | Const z     -> z
+      | Add  (x, y) -> eval' x + eval' y
+      | Mul  (x, y) -> eval' x * eval' y
+
+  end
+
+(* Interpreter for statements *)
+module Stmt =
+  struct
+
+    open Stmt
+
+    (* State update primitive *) 
+    let update st x v = fun y -> if y = x then v else st y 
+      
+    let rec eval stmt ((st, input, output) as conf) =
+      match stmt with
+      | Skip          -> conf
+      | Assign (x, e) -> (update st x (Expr.eval e st), input, output)
+      | Read    x     -> 
+	  let z :: input' = input in
+	  (update st x z, input', output)
+      | Write   e     -> (st, input, output @ [Expr.eval e st])
+      | Seq (s1, s2)  -> eval s1 conf |> eval s2 
+
+  end
+
+module Program =
+  struct
+
+    let eval p input = 
+      let (_, _, output) = 
+	Stmt.eval p ((fun _ -> failwith "undefined variable"), input, []) 
+      in
+      output
+
+  end
diff --git a/ChulanovAndrey/Language.ml b/ChulanovAndrey/Language.ml
new file mode 100644
index 0000000..fe351f5
--- /dev/null
+++ b/ChulanovAndrey/Language.ml
@@ -0,0 +1,34 @@
+open GT
+
+(* AST for expressions *)
+module Expr =
+  struct
+
+    @type t =
+    | Var   of string
+    | Const of int
+    | Add   of t * t
+    | Mul   of t * t with show
+
+  end
+
+(* AST statements/commands *)
+module Stmt =
+  struct
+
+    @type t =
+    | Skip
+    | Assign of string * Expr.t
+    | Read   of string
+    | Write  of Expr.t
+    | Seq    of t * t with show
+
+  end
+
+module Program =
+  struct
+
+    type t = Stmt.t
+
+  end
+
diff --git a/ChulanovAndrey/Makefile b/ChulanovAndrey/Makefile
new file mode 100644
index 0000000..f9ca8c5
--- /dev/null
+++ b/ChulanovAndrey/Makefile
@@ -0,0 +1,20 @@
+all: Driver.cmo
+	ocamlc -rectypes -o compiler -I `ocamlfind -query GT` -I `ocamlfind -query ostap` -I `ocamlfind -query re.str` re.cma re_emacs.cma re_str.cma GT.cma ostap.cmo Language.cmo Interpret.cmo StackMachine.cmo X86.cmo Driver.cmo
+
+Language.cmo: Language.ml
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
+
+Interpret.cmo: Interpret.ml Language.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
+
+StackMachine.cmo: StackMachine.ml Language.cmo Interpret.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
+
+X86.cmo: X86.ml StackMachine.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
+
+Driver.cmo: Driver.ml StackMachine.cmo X86.cmo Interpret.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma Driver.ml
+
+clean:
+	rm -Rf *~ *.cmo compiler
diff --git a/ChulanovAndrey/README.md b/ChulanovAndrey/README.md
new file mode 100644
index 0000000..533f946
--- /dev/null
+++ b/ChulanovAndrey/README.md
@@ -0,0 +1,29 @@
+Dependencies:
+
+`$ opam pin add GT https://github.com/Kakadu/GT.git -n -y`
+
+`$ opam install camlp5 -y`
+
+`$ opam install GT ocamlfind -y`
+
+Build & use: 
+
+`$ make`
+
+`$ gcc -m32 -c runtime.c`
+
+`$ RUNTIME=. ./compiler file.expr`
+
+`$ ./file`
+
+If make fails with an error which states that GT.Syntax.All cannot be found, make sure you initialized and configured opam: 
+
+`$ opam init`
+
+``$ eval `opam config env` ``
+
+Ostap library: 
+
+`$ opam pin add ostap https://github.com/dboulytchev/ostap.git -n -y`
+
+`$ opam install ostap -y`
diff --git a/ChulanovAndrey/StackMachine.ml b/ChulanovAndrey/StackMachine.ml
new file mode 100644
index 0000000..870537a
--- /dev/null
+++ b/ChulanovAndrey/StackMachine.ml
@@ -0,0 +1,102 @@
+(* Stack Machine *)
+module Instr =
+  struct
+
+    type t =
+      | READ
+      | WRITE
+      | PUSH of int
+      | LD   of string
+      | ST   of string
+      | ADD  
+      | MUL
+
+  end
+
+module Program =
+  struct
+
+    type t = Instr.t list
+
+  end
+
+module Interpret =
+  struct
+
+    open Instr
+    open Interpret.Stmt
+
+    let run prg input =
+      let rec run' prg ((stack, st, input, output) as conf) =
+	match prg with
+	| []        -> conf
+	| i :: prg' ->
+            run' prg' (
+            match i with
+            | READ  -> let z :: input' = input in
+              (z :: stack, st, input', output)
+            | WRITE -> let z :: stack' = stack in
+              (stack', st, input, output @ [z])
+	    | PUSH n -> (n :: stack, st, input, output)
+            | LD   x -> (st x :: stack, st, input, output)
+	    | ST   x -> let z :: stack' = stack in
+              (stack', update st x z, input, output)
+	    | _ -> let y :: x :: stack' = stack in
+              ((match i with ADD -> (+) | _ -> ( * )) x y :: stack', 
+               st, 
+               input, 
+               output
+              )
+           )
+      in
+      let (_, _, _, output) = 
+	run' prg ([], 
+	          (fun _ -> failwith "undefined variable"),
+	          input,
+	          []
+	         ) 
+      in
+      output
+  end
+
+module Compile =
+  struct
+
+    open Instr
+
+    module Expr =
+      struct
+
+	open Language.Expr
+
+	let rec compile = function 
+	| Var x      -> [LD   x]
+	| Const n    -> [PUSH n]
+	| Add (x, y) -> (compile x) @ (compile y) @ [ADD]
+	| Mul (x, y) -> (compile x) @ (compile y) @ [MUL]
+
+      end
+
+    module Stmt =
+      struct
+
+	open Language.Stmt
+
+	let rec compile = function
+	| Skip          -> []
+	| Assign (x, e) -> Expr.compile e @ [ST x]
+	| Read    x     -> [READ; ST x]
+	| Write   e     -> Expr.compile e @ [WRITE]
+	| Seq    (l, r) -> compile l @ compile r
+
+      end
+
+    module Program =
+      struct
+
+	let compile = Stmt.compile
+
+      end
+
+  end
+
diff --git a/ChulanovAndrey/X86.ml b/ChulanovAndrey/X86.ml
new file mode 100644
index 0000000..b68c1dd
--- /dev/null
+++ b/ChulanovAndrey/X86.ml
@@ -0,0 +1,124 @@
+open StackMachine
+open Instr
+
+type opnd = R of int | S of int | L of int | M of string
+
+let regs  = [|"%eax"; "%ebx"; "%ecx"; "%esi"; "%edi"; "%edx"; "%esp"; "%ebp"|]
+let nregs = Array.length regs - 3
+
+let [|eax; ebx; ecx; esi; edi; edx; esp; ebp|] = Array.mapi (fun i _ -> R i) regs
+
+type instr =
+| Add  of opnd * opnd
+| Mul  of opnd * opnd
+| Mov  of opnd * opnd
+| Push of opnd
+| Pop  of opnd
+| Call of string
+| Ret
+
+let to_string buf code =      
+  let instr =
+    let opnd = function
+      | R i -> regs.(i)
+      | S i -> Printf.sprintf "%d(%%ebp)" (-i * 4)
+      | L i -> Printf.sprintf "$%d" i
+      | M s -> s  
+    in
+    function
+      | Add (x, y) -> Printf.sprintf "addl\t%s,%s"  (opnd x) (opnd y)
+      | Mul (x, y) -> Printf.sprintf "imull\t%s,%s" (opnd x) (opnd y)
+      | Mov (x, y) -> Printf.sprintf "movl\t%s,%s"  (opnd x) (opnd y)
+      | Push x     -> Printf.sprintf "pushl\t%s"    (opnd x)
+      | Pop  x     -> Printf.sprintf "popl\t%s"     (opnd x)
+      | Call x     -> Printf.sprintf "call\t%s"      x
+      | Ret        -> "ret" 
+  in
+  let out s = 
+    Buffer.add_string buf "\t"; 
+    Buffer.add_string buf s; 
+    Buffer.add_string buf "\n" 
+  in
+  List.iter (fun i -> out @@ instr i) code
+    
+module S = Set.Make (String)
+    
+class env =
+  object (this)
+    val locals = S.empty
+    val depth  = 0
+	
+    method allocate = function
+      | []                          -> this, R 0
+      | R i :: _ when i < nregs - 1 -> this, R (i+1)
+      | S i :: _                    -> {< depth = max depth (i+1) >}, S (i+1)
+      | _                           -> {< depth = max depth 1 >}, S 1 
+	    
+    method local     x = {< locals = S.add x locals >}
+    method get_locals  = S.elements locals
+    method get_depth   = depth
+  end
+    
+let rec sint env prg sstack =
+  match prg with
+  | []        -> env, [], []
+  | i :: prg' ->
+      let env, code, sstack' = 
+	match i with
+	| PUSH n ->  
+            let env', s = env#allocate sstack in
+            env', [Mov (L n, s)], s :: sstack
+        | LD x ->
+            let env'     = env#local x in
+            let env'', s = env'#allocate sstack in
+            env'', 
+			(match s with (* Нельзя командой mov писать из памяти в память, так что используем регистр edx*)
+			| S _ [Mov (M x, edx); Mov (edx, s)]
+			| _ [Mov (M x, s)]
+			), s :: sstack
+	| ST x ->
+            let env' = env#local x in
+            let s :: sstack' = sstack in
+            env', 
+			(match s with
+			| S _ -> [Mov (s, edx); Mov (edx, M x)]
+			| _   -> [Mov (s, M x)]
+			), sstack' 
+        | READ  ->
+            env, [Call "lread"], [eax]
+        | WRITE ->
+            env, [Push eax; Call "lwrite"; Pop edx], [] 
+        | _ ->
+            let x::(y::_ as sstack') = sstack in
+            (fun op ->
+              match x, y with
+              | S _, S _ -> env, [Mov (y, edx); op x edx; Mov (edx, y)], sstack'
+              | _        -> env, [op x y], sstack'   
+            )
+              (match i with 
+	      | MUL -> fun x y -> Mul (x, y)
+	      | ADD -> fun x y -> Add (x, y)
+              )
+      in
+      let env, code', sstack'' = sint env prg' sstack' in
+      env, code @ code', sstack''
+	
+let compile p = 
+  let env, code, [] = sint (new env) (Compile.Program.compile p) [] in
+  let buf   = Buffer.create 1024 in
+  let out s = Buffer.add_string buf s in
+  out "\t.data\n";
+  List.iter (fun x -> out (Printf.sprintf "%s:\t.int 0\n" x)) 
+    env#get_locals;
+  out "\t.text\n";
+  out "\t.globl\tmain\n";
+  out "main:\n";
+  out "\tpushl\t%ebp\n";
+  out "\tmovl\t%esp,%ebp\n";
+  out (Printf.sprintf "\tsubl\t$%d,%%esp\n" (env#get_depth * 4));
+  to_string buf code;
+  out "\tmovl\t%ebp,%esp\n";
+  out "\tpopl\t%ebp\n";
+  out "\tret\n";
+  Buffer.contents buf
+    
diff --git a/ChulanovAndrey/runtime.c b/ChulanovAndrey/runtime.c
new file mode 100644
index 0000000..4db6da7
--- /dev/null
+++ b/ChulanovAndrey/runtime.c
@@ -0,0 +1,12 @@
+# include <stdio.h>
+
+int lread () {
+  int d;
+  printf ("> ");
+  scanf ("%d", &d);
+  return d;
+}
+
+void lwrite (int n) {
+  printf ("< %d\n", n);
+}
diff --git a/Driver.ml b/Driver.ml
index a6c02f5..fab362c 100644
--- a/Driver.ml
+++ b/Driver.ml
@@ -1,55 +1,59 @@
-open Expr
-open GT
-
-(* EDSL = Embedded Domain-Specific Language
-          Встроенный предметно-ориентированный язык
-   Deep Embedding
-*)
-
-let inc x = x+1
-
-let ( !  ) x   = Var   x
-let const  n   = Const n
-let ( +  ) x y = Add  (x, y)
-let ( *  ) x y = Mul  (x, y)
-
-let read  x  = Read  x
-let write e  = Write e
-let (:=) x e = Assign (x, e)
-let skip     = Skip
-let (|>) l r = Seq (l, r)
-
-(*
-  read (x);
-  read (y);
-  z := x * y;
-  write (z)
-*)
-  
-let p =
-  read "x" |>
-  read "y" |>
-  ("z" := !"x" * !"y" + const 1) |>
-  write !"z"
-
-let _ =
-  Printf.printf "%s\n" (show(list) (show(int)) @@ run p [10; 20]);
-  Printf.printf "%s\n" (show(list) (show(int)) @@ srun (comp p) [10; 20])
-
-let gen n =
-  let rec gen_read n i =
-    if i > n 
-    then skip
-    else read (Printf.sprintf "x%d" i) |> gen_read n (inc i)
-  in
-  let rec gensum n i =
-    if i > n 
-    then Const 0
-    else !(Printf.sprintf "x%d" i) + gensum n (inc i)
-  in
-  gen_read n 0 |>
-  write @@ gensum n 0
-
-(*let _ =
-  Printf.printf "%s" (show(stmt) @@ gen 300)
-*)
+open Language
+open Expr
+open Stmt
+open Ostap
+open GT
+
+ostap (
+  expr : expr "+" expr 
+)
+
+ostap (
+  expr: x:mull "+" y:expr {Add (x,y)} 
+      | mull;
+  mull: x:prim "*" y:mull {Mul (x,y)}
+      | prim; 
+  prim: n:DECIMAL {Const n}  
+      | e:IDENT   {Var e}
+      | -"(" expr -")"
+(*       | "(" e:expr ")" {e} *)
+)
+
+ostap (
+  simp: x:IDENT ":=" e:expr     {Assign (x, e)}
+      | %"read" "(" x:IDENT ")" {Read x}
+      | %"write" "(" e:expr ")" {Write e}
+      | %"skip"                 {Skip};
+      
+  stmt: s:simp ";" d:stmt {Seq (s,d)}
+      | simp 
+)
+
+let parse filename = 
+  let s = Util.read filename in
+  Util.parse 
+    (object 
+       inherit Matcher.t s 
+       inherit Util.Lexers.ident ["read"; "write"; "skip"] s
+       inherit Util.Lexers.decimal s
+       inherit Util.Lexers.skip [
+         Matcher.Skip.whitespaces " \t\n"
+       ] s
+    end)
+    (ostap (stmt -EOF))
+    
+let _ =
+  match Sys.argv with
+  | [|_; filename|] ->
+      match parse filename with
+      | `Ok stmt -> 
+        let basename = Filename.chop_suffix filename ".expr" in      
+        let text = X86.compile stmt in
+        Printf.printf "%s\n" (show (Stmt.t) stmt);
+        let asm  = basename ^ ".s" in
+        let ouch = open_out asm   in
+      Printf.fprintf ouch "%s\n" text;
+      close_out ouch;
+        let runtime = try Sys.getenv "RUNTIME" with _ -> "../runtime" in
+        ignore @@ Sys.command (Printf.sprintf "gcc -m32 -o %s %s/runtime.o %s.s" basename runtime basename)
+      | `Fail e -> Printf.eprintf "Parsing error: %s\n" e
diff --git a/Expr.ml b/Expr.ml
deleted file mode 100644
index 44aa681..0000000
--- a/Expr.ml
+++ /dev/null
@@ -1,149 +0,0 @@
-(* AST for expressions *)
-open GT
-
-@type expr =
-| Var   of string
-| Const of int
-| Add   of expr * expr
-| Mul   of expr * expr with show
-
-(* AST statements/commands *)
-@type stmt =
-| Skip
-| Assign of string * expr
-| Read   of string
-| Write  of expr
-| Seq    of stmt * stmt with show
-
-(* Interpreter for expressions *)
-let rec eval expr st = 
-  let eval' e = eval e st in
-  match expr with
-  | Var   x     -> st x
-  | Const z     -> z
-  | Add  (x, y) -> eval' x + eval' y
-  | Mul  (x, y) -> eval' x * eval' y
-
-(* State update primitive *) 
-let update st x v = fun y -> if y = x then v else st y 
-
-(* Interpreter for statements *)
-let run stmt input =
-  let rec run' stmt ((st, input, output) as conf) =
-    match stmt with
-    | Skip          -> conf
-    | Assign (x, e) -> (update st x (eval e st), input, output)
-    | Read    x     -> 
-       let z :: input' = input in
-       (update st x z, input', output)
-    | Write   e     -> (st, input, output @ [eval e st])
-    | Seq (s1, s2)  -> run' s1 conf |> run' s2 
-  in
-  let (_, _, output) = 
-    run' stmt ((fun _ -> failwith "undefined variable"), input, []) 
-  in
-  output
-
-(* Stack Machine *)
-type instr =
-| READ
-| WRITE
-| PUSH of int
-| LD   of string
-| ST   of string
-| ADD  
-| MUL
-
-type prg = instr list
-
-let srun prg input =
-  let rec srun' prg ((stack, st, input, output) as conf) =
-    match prg with
-    | []        -> conf
-    | i :: prg' ->
-        srun' prg' (
-          match i with
-          | READ  -> let z :: input' = input in
-                     (z :: stack, st, input', output)
-          | WRITE -> let z :: stack' = stack in
-                     (stack', st, input, output @ [z])
-	  | PUSH n -> (n :: stack, st, input, output)
-          | LD   x -> (st x :: stack, st, input, output)
-	  | ST   x -> let z :: stack' = stack in
-                      (stack', update st x z, input, output)
-	  | _ -> let y :: x :: stack' = stack in
-                 ((match i with ADD -> (+) | _ -> ( * )) x y :: stack', 
-                  st, 
-                  input, 
-                  output
-                 )
-        )
-  in
-  let (_, _, _, output) = 
-    srun' prg ([], 
-              (fun _ -> failwith "undefined variable"),
-              input,
-              []
-             ) 
-  in
-  output
-
-let rec comp_expr = function 
-| Var x      -> [LD   x]
-| Const n    -> [PUSH n]
-| Add (x, y) -> (comp_expr x) @ (comp_expr y) @ [ADD]
-| Mul (x, y) -> (comp_expr x) @ (comp_expr y) @ [MUL]
-
-let rec comp = function
-| Skip          -> []
-| Assign (x, e) -> comp_expr e @ [ST x]
-| Read    x     -> [READ; ST x]
-| Write   e     -> comp_expr e @ [WRITE]
-| Seq    (l, r) -> comp l @ comp r
-
-module X86 =
-  struct
-
-    type opnd = R of int | S of int | L of int | M of string
-
-    let regs  = [|"%eax"; "%ebx"; "%ecx"; "%esi"; "%edi"|]
-    let nregs = Array.length regs
-
-    type instr =
-    | Add  of opnd * opnd
-    | Mul  of opnd * opnd
-    | Mov  of opnd * opnd
-    | Push of opnd
-    | Pop  of opnd
-    | Call of string
-    | Ret
-
-    let allocate = function
-    | []                          -> R 0
-    | R i :: _ when i < nregs - 1 -> R (i+1)
-    | S i :: _                    -> S (i+1)
-    | _                           -> S 0 
-
-    let rec sint prg sstack =
-      match prg with
-      | []        -> [], []
-      | i :: prg' ->
-          let (code, sstack') = 
-	    match i with
-	    | PUSH n -> 
-                let s = allocate sstack in
-                [Mov (L n, s)], s :: sstack
-            | LD x ->
-                let s = allocate sstack in
-                [Mov (M x, s)], s :: sstack
-	    | ST x ->
-                let s :: sstack' = sstack in
-                [Mov (s, M x)], sstack' 
-          in
-          let (code', sstack'') = sint prg' sstack' in
-          code @ code', sstack''
-(*
-    let compile stmt = 
-      sint (comp stmt) 
-*)
-  end
diff --git a/Interpret.ml b/Interpret.ml
new file mode 100644
index 0000000..ff16b03
--- /dev/null
+++ b/Interpret.ml
@@ -0,0 +1,49 @@
+open Language
+
+(* Interpreter for expressions *)
+module Expr =
+  struct
+
+    open Expr
+
+    let rec eval expr st = 
+      let eval' e = eval e st in
+      match expr with
+      | Var   x     -> st x
+      | Const z     -> z
+      | Add  (x, y) -> eval' x + eval' y
+      | Mul  (x, y) -> eval' x * eval' y
+
+  end
+
+(* Interpreter for statements *)
+module Stmt =
+  struct
+
+    open Stmt
+
+    (* State update primitive *) 
+    let update st x v = fun y -> if y = x then v else st y 
+      
+    let rec eval stmt ((st, input, output) as conf) =
+      match stmt with
+      | Skip          -> conf
+      | Assign (x, e) -> (update st x (Expr.eval e st), input, output)
+      | Read    x     -> 
+	  let z :: input' = input in
+	  (update st x z, input', output)
+      | Write   e     -> (st, input, output @ [Expr.eval e st])
+      | Seq (s1, s2)  -> eval s1 conf |> eval s2 
+
+  end
+
+module Program =
+  struct
+
+    let eval p input = 
+      let (_, _, output) = 
+	Stmt.eval p ((fun _ -> failwith "undefined variable"), input, []) 
+      in
+      output
+
+  end
diff --git a/Language.ml b/Language.ml
new file mode 100644
index 0000000..fe351f5
--- /dev/null
+++ b/Language.ml
@@ -0,0 +1,34 @@
+open GT
+
+(* AST for expressions *)
+module Expr =
+  struct
+
+    @type t =
+    | Var   of string
+    | Const of int
+    | Add   of t * t
+    | Mul   of t * t with show
+
+  end
+
+(* AST statements/commands *)
+module Stmt =
+  struct
+
+    @type t =
+    | Skip
+    | Assign of string * Expr.t
+    | Read   of string
+    | Write  of Expr.t
+    | Seq    of t * t with show
+
+  end
+
+module Program =
+  struct
+
+    type t = Stmt.t
+
+  end
+
diff --git a/Makefile b/Makefile
index d509e12..f9ca8c5 100644
--- a/Makefile
+++ b/Makefile
@@ -1,11 +1,20 @@
 all: Driver.cmo
-	ocamlc -rectypes -o Driver -I `ocamlfind -query GT` GT.cma Expr.cmo Driver.cmo
+	ocamlc -rectypes -o compiler -I `ocamlfind -query GT` -I `ocamlfind -query ostap` -I `ocamlfind -query re.str` re.cma re_emacs.cma re_str.cma GT.cma ostap.cmo Language.cmo Interpret.cmo StackMachine.cmo X86.cmo Driver.cmo
 
-Expr.cmo: Expr.ml
-	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` GT.cma $<
+Language.cmo: Language.ml
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
 
-Driver.cmo: Expr.cmo Driver.ml
-	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` GT.cma Driver.ml
+Interpret.cmo: Interpret.ml Language.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
+
+StackMachine.cmo: StackMachine.ml Language.cmo Interpret.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
+
+X86.cmo: X86.ml StackMachine.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma $<
+
+Driver.cmo: Driver.ml StackMachine.cmo X86.cmo Interpret.cmo
+	ocamlc -rectypes -c -pp "camlp5o -I `ocamlfind -query GT.syntax.all` pa_gt.cmo -I `ocamlfind -query ostap` pa_ostap.cmo -L `ocamlfind -query GT.syntax.all`" -I `ocamlfind -query GT` -I `ocamlfind -query ostap` GT.cma Driver.ml
 
 clean:
-	rm -Rf *~ *.cmo Driver
+	rm -Rf *~ *.cmo compiler
diff --git a/README.md b/README.md
index 3cb279c..533f946 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,29 @@
 Dependencies:
 
-opam pin add GT https://github.com/Kakadu/GT.git -n -y
+`$ opam pin add GT https://github.com/Kakadu/GT.git -n -y`
 
-opam install camlp5 -y
+`$ opam install camlp5 -y`
 
-opam install GT ocamlfind -y
+`$ opam install GT ocamlfind -y`
+
+Build & use: 
+
+`$ make`
+
+`$ gcc -m32 -c runtime.c`
+
+`$ RUNTIME=. ./compiler file.expr`
+
+`$ ./file`
+
+If make fails with an error which states that GT.Syntax.All cannot be found, make sure you initialized and configured opam: 
+
+`$ opam init`
+
+``$ eval `opam config env` ``
+
+Ostap library: 
+
+`$ opam pin add ostap https://github.com/dboulytchev/ostap.git -n -y`
+
+`$ opam install ostap -y`
diff --git a/StackMachine.ml b/StackMachine.ml
new file mode 100644
index 0000000..870537a
--- /dev/null
+++ b/StackMachine.ml
@@ -0,0 +1,102 @@
+(* Stack Machine *)
+module Instr =
+  struct
+
+    type t =
+      | READ
+      | WRITE
+      | PUSH of int
+      | LD   of string
+      | ST   of string
+      | ADD  
+      | MUL
+
+  end
+
+module Program =
+  struct
+
+    type t = Instr.t list
+
+  end
+
+module Interpret =
+  struct
+
+    open Instr
+    open Interpret.Stmt
+
+    let run prg input =
+      let rec run' prg ((stack, st, input, output) as conf) =
+	match prg with
+	| []        -> conf
+	| i :: prg' ->
+            run' prg' (
+            match i with
+            | READ  -> let z :: input' = input in
+              (z :: stack, st, input', output)
+            | WRITE -> let z :: stack' = stack in
+              (stack', st, input, output @ [z])
+	    | PUSH n -> (n :: stack, st, input, output)
+            | LD   x -> (st x :: stack, st, input, output)
+	    | ST   x -> let z :: stack' = stack in
+              (stack', update st x z, input, output)
+	    | _ -> let y :: x :: stack' = stack in
+              ((match i with ADD -> (+) | _ -> ( * )) x y :: stack', 
+               st, 
+               input, 
+               output
+              )
+           )
+      in
+      let (_, _, _, output) = 
+	run' prg ([], 
+	          (fun _ -> failwith "undefined variable"),
+	          input,
+	          []
+	         ) 
+      in
+      output
+  end
+
+module Compile =
+  struct
+
+    open Instr
+
+    module Expr =
+      struct
+
+	open Language.Expr
+
+	let rec compile = function 
+	| Var x      -> [LD   x]
+	| Const n    -> [PUSH n]
+	| Add (x, y) -> (compile x) @ (compile y) @ [ADD]
+	| Mul (x, y) -> (compile x) @ (compile y) @ [MUL]
+
+      end
+
+    module Stmt =
+      struct
+
+	open Language.Stmt
+
+	let rec compile = function
+	| Skip          -> []
+	| Assign (x, e) -> Expr.compile e @ [ST x]
+	| Read    x     -> [READ; ST x]
+	| Write   e     -> Expr.compile e @ [WRITE]
+	| Seq    (l, r) -> compile l @ compile r
+
+      end
+
+    module Program =
+      struct
+
+	let compile = Stmt.compile
+
+      end
+
+  end
+
diff --git a/X86.ml b/X86.ml
new file mode 100644
index 0000000..6ff88b0
--- /dev/null
+++ b/X86.ml
@@ -0,0 +1,116 @@
+open StackMachine
+open Instr
+
+type opnd = R of int | S of int | L of int | M of string
+
+let regs  = [|"%eax"; "%ebx"; "%ecx"; "%esi"; "%edi"; "%edx"; "%esp"; "%ebp"|]
+let nregs = Array.length regs - 3
+
+let [|eax; ebx; ecx; esi; edi; edx; esp; ebp|] = Array.mapi (fun i _ -> R i) regs
+
+type instr =
+| Add  of opnd * opnd
+| Mul  of opnd * opnd
+| Mov  of opnd * opnd
+| Push of opnd
+| Pop  of opnd
+| Call of string
+| Ret
+
+let to_string buf code =      
+  let instr =
+    let opnd = function
+      | R i -> regs.(i)
+      | S i -> Printf.sprintf "%d(%%ebp)" (-i * 4)
+      | L i -> Printf.sprintf "$%d" i
+      | M s -> s  
+    in
+    function
+      | Add (x, y) -> Printf.sprintf "addl\t%s,%s"  (opnd x) (opnd y)
+      | Mul (x, y) -> Printf.sprintf "imull\t%s,%s" (opnd x) (opnd y)
+      | Mov (x, y) -> Printf.sprintf "movl\t%s,%s"  (opnd x) (opnd y)
+      | Push x     -> Printf.sprintf "pushl\t%s"    (opnd x)
+      | Pop  x     -> Printf.sprintf "popl\t%s"     (opnd x)
+      | Call x     -> Printf.sprintf "call\t%s"      x
+      | Ret        -> "ret" 
+  in
+  let out s = 
+    Buffer.add_string buf "\t"; 
+    Buffer.add_string buf s; 
+    Buffer.add_string buf "\n" 
+  in
+  List.iter (fun i -> out @@ instr i) code
+    
+module S = Set.Make (String)
+    
+class env =
+  object (this)
+    val locals = S.empty
+    val depth  = 0
+	
+    method allocate = function
+      | []                          -> this, R 0
+      | R i :: _ when i < nregs - 1 -> this, R (i+1)
+      | S i :: _                    -> {< depth = max depth (i+1) >}, S (i+1)
+      | _                           -> {< depth = max depth 1 >}, S 1 
+	    
+    method local     x = {< locals = S.add x locals >}
+    method get_locals  = S.elements locals
+    method get_depth   = depth
+  end
+    
+let rec sint env prg sstack =
+  match prg with
+  | []        -> env, [], []
+  | i :: prg' ->
+      let env, code, sstack' = 
+	match i with
+	| PUSH n ->  
+            let env', s = env#allocate sstack in
+            env', [Mov (L n, s)], s :: sstack
+        | LD x ->
+            let env'     = env#local x in
+            let env'', s = env'#allocate sstack in
+            env'', [Mov (M x, s)], s :: sstack
+	| ST x ->
+            let env' = env#local x in
+            let s :: sstack' = sstack in
+            env', [Mov (s, M x)], sstack' 
+        | READ  ->
+            env, [Call "lread"], [eax]
+        | WRITE ->
+            env, [Push eax; Call "lwrite"; Pop edx], [] 
+        | _ ->
+            let x::(y::_ as sstack') = sstack in
+            (fun op ->
+              match x, y with
+              | S _, S _ -> env, [Mov (y, edx); op x edx; Mov (edx, y)], sstack'
+              | _        -> env, [op x y], sstack'   
+            )
+              (match i with 
+	      | MUL -> fun x y -> Mul (x, y)
+	      | ADD -> fun x y -> Add (x, y)
+              )
+      in
+      let env, code', sstack'' = sint env prg' sstack' in
+      env, code @ code', sstack''
+	
+let compile p = 
+  let env, code, [] = sint (new env) (Compile.Program.compile p) [] in
+  let buf   = Buffer.create 1024 in
+  let out s = Buffer.add_string buf s in
+  out "\t.data\n";
+  List.iter (fun x -> out (Printf.sprintf "%s:\t.int 0\n" x)) 
+    env#get_locals;
+  out "\t.text\n";
+  out "\t.globl\tmain\n";
+  out "main:\n";
+  out "\tpushl\t%ebp\n";
+  out "\tmovl\t%esp,%ebp\n";
+  out (Printf.sprintf "\tsubl\t$%d,%%esp\n" (env#get_depth * 4));
+  to_string buf code;
+  out "\tmovl\t%ebp,%esp\n";
+  out "\tpopl\t%ebp\n";
+  out "\tret\n";
+  Buffer.contents buf
+    
diff --git a/runtime.c b/runtime.c
new file mode 100644
index 0000000..4db6da7
--- /dev/null
+++ b/runtime.c
@@ -0,0 +1,12 @@
+# include <stdio.h>
+
+int lread () {
+  int d;
+  printf ("> ");
+  scanf ("%d", &d);
+  return d;
+}
+
+void lwrite (int n) {
+  printf ("< %d\n", n);
+}
